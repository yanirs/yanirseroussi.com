---
title: Making Bayesian A/B testing more accessible
author: Yanir Seroussi
type: post
date: 2016-06-19T10:32:15+00:00
url: /2016/06/19/making-bayesian-ab-testing-more-accessible/
cover:
  image: bayesian-split-testing-calculator.png
tags:
  - a/b testing
  - analytics
  - causal inference
  - causality
  - data science
  - split testing
  - statistics

---
Much has been written in recent years on the pitfalls of using traditional hypothesis testing with online A/B tests. A key issue is that <a href="http://www.evanmiller.org/how-not-to-run-an-ab-test.html" target="_blank" rel="noopener">you're likely to end up with many false positives if you repeatedly check your results and stop as soon as you reach statistical significance</a>. One way of dealing with this issue is by <a href="http://www.evanmiller.org/bayesian-ab-testing.html" target="_blank" rel="noopener">following a Bayesian approach</a> to deciding when the experiment should be stopped. While I find the Bayesian view of statistics much more intuitive than the frequentist view, it can be quite challenging to explain Bayesian concepts to laypeople. Hence, I decided to build a new <a href="https://yanirs.github.io/tools/split-test-calculator/" target="_blank" rel="noopener">Bayesian A/B testing calculator</a>, which aims to make these concepts clear to any user. This post discusses the general problem and existing solutions, followed by a review of the new tool and how it can be improved further.

## The problem

The classic A/B testing problem is as follows. Suppose we run an experiment where we have a control group and a test group. Participants (typically website visitors) are allocated to groups randomly, and each group is presented with a different variant of the website or page (e.g., variant A is assigned to the control group and variant B is assigned to the test group). Our aim is to increase the overall number of binary _successes_, where success can be defined as clicking a button or opening a new account. Hence, we track the number of _trials_ in each group together with the number of successes. For a given group, the number of successes divided by number of trials is the group's raw success rate.

Given the results of an experiment (trials and successes for each group), there are a few questions we would typically like to answer:

  1. Should we choose variant A or variant B to maximise our success rate?
  2. How much would our success rate change if we chose one variant over the other?
  3. Do we have enough data or should we keep experimenting?

It's important to note some points that might be obvious, but are often overlooked. First, we run an experiment because we assume that it will help us uncover a [causal link][1], where something about A or B is hypothesised to cause people to behave differently, thereby affecting the overall success rate. Second, we _want_ to make a decision and choose either A or B, rather than maintain multiple variants and present the best variant depending on a participant's features (a problem that's addressed by <a href="https://en.wikipedia.org/wiki/Multi-armed_bandit#Contextual_Bandit" target="_blank" rel="noopener">contextual bandits</a>, for example). Third, online A/B testing is different from traditional experiments in a lab, because we often have little control over the characteristics of our participants, and when, where, and how they choose to interact with our experiment. This is an important point, because it means that we may need to wait a long time until we get a representative sample of the population. In addition, the raw numbers of trials and successes can't tell us whether the sample is representative.

## Bayesian solutions

Many blog posts have been written on how to use Bayesian statistics to answer the above questions, so I won't get into too much detail here (see the posts by <a href="http://varianceexplained.org/r/bayesian_ab_baseball/" target="_blank" rel="noopener">David Robinson</a>, <a href="http://developers.lyst.com/2014/05/10/bayesian-ab-testing/" target="_blank" rel="noopener">Maciej Kula</a>, <a href="https://www.chrisstucchio.com/blog/2014/bayesian_ab_decision_rule.html" target="_blank" rel="noopener">Chris Stucchio</a>, and <a href="http://www.evanmiller.org/bayesian-ab-testing.html" target="_blank" rel="noopener">Evan Miller</a> if you need more background). The general idea is that we assume that the success rates for the control and test variants are drawn from Beta(&alpha;<sub>A</sub>, &beta;<sub>A</sub>) and Beta(&alpha;<sub>B</sub>, &beta;<sub>B</sub>), respectively, where Beta(&alpha;, &beta;) is the <a href="https://en.wikipedia.org/wiki/Beta_distribution" target="_blank" rel="noopener">beta distribution</a> with shape parameters &alpha; and &beta; (which yields values in the [0, 1] interval). As the experiment runs, we update the parameters of the distributions &ndash; each success gets added to the group's &alpha;, and each unsuccessful trial gets added to the group's &beta;. It is often reasonable to assume that the prior (i.e., initial) values of &alpha; and &beta; are the same for both variants. If we denote the prior values of the parameters with &alpha;<sub></sub> and &beta;<sub></sub>, and the number of successes and trials for group x with S<sub>x</sub> and T<sub>x</sub> respectively, we get that the success rates are distributed according to Beta(&alpha;<sub></sub> + S<sub>A</sub>, &beta;<sub></sub> + T<sub>A</sub> &#8211; S<sub>A</sub>) for control and Beta(&alpha;<sub></sub> + S<sub>B</sub>, &beta;<sub></sub> + T<sub>B</sub> &#8211; S<sub>B</sub>) for test.

For example, if &alpha;<sub></sub> = &beta;<sub></sub> = 1, T<sub>A</sub> = 200, S<sub>A</sub> = 120, T<sub>B</sub> = 200, and S<sub>B</sub> = 100, plotting the probability density functions yields the following chart (A &#8211; blue, B &#8211; red):

{{< figure src="beta-distributions-examples.png" alt="Beta distributions examples" >}}

Given these distributions, we can calculate the most probable range for the success rate of each variant, and estimate the difference in success rate between the variants. These can be calculated by <a href="http://www.evanmiller.org/bayesian-ab-testing.html" target="_blank" rel="noopener">deriving closed formulas</a>, or by <a href="http://varianceexplained.org/r/bayesian_ab_baseball/" target="_blank" rel="noopener">drawing samples from each distribution</a>. In addition, it is important to note that the distributions change as we gather more data, even if the raw success rates don't. For example, multiplying each count by 10 to obtain T<sub>A</sub> = 2000, S<sub>A</sub> = 1200, T<sub>B</sub> = 2000, and S<sub>B</sub> = 1000 doesn't change the success rates, but it does change the distributions &ndash; they become much narrower:

{{< figure src="beta-distributions-examples-narrower.png" alt="Narrower beta distributions" >}}

In the second case we've gathered ten times the data, which made the distributions much more distinct. Intuitively, this means we can now be more confident that the success rate of A is higher than that of B. Quantifying this confidence and deciding when to conclude the experiment isn't straightforward, and should depend on factors that aren't fully captured by the raw counts. The way I chose to address this issue is presented below, after briefly discussing existing calculators and their limitations.

## Existing online calculators

The beauty of frequentist tools for significance testing is that they always give you a simple answer. For example, if we plug the numbers from the first case above (T<sub>A</sub> = 200, S<sub>A</sub> = 120, T<sub>B</sub> = 200, and S<sub>B</sub> = 100) into <a href="http://www.evanmiller.org/ab-testing/chi-squared.html" target="_blank" rel="nofollow noopener">Evan Miller's calculator</a>, we get:

{{< figure src="chi-squared-test-example.png" alt="Chi-Squared test example" link="http://www.evanmiller.org/ab-testing/chi-squared.html#!120/200;100/200@95" >}}

Unfortunately, both Bayesian calculators that I'm aware of have some limitations. Plugging the same numbers into the calculators by <a href="https://www.peakconversion.com/2012/02/ab-split-test-graphical-calculator/" target="_blank" rel="nofollow noopener">PeakConversion</a> and <a href="http://developers.lyst.com/bayesian-calculator/" target="_blank" rel="nofollow noopener">Lyst</a> would inform you that the probability of A being best is approximately 0.98, but it won't tell you what's the best way forward given this information. PeakConversion also outputs the 95% success rate intervals for A (between 53.1% and 66.7%) and B (between 43.1% and 56.9%), but it doesn't let users set the prior values &alpha;<sub></sub> and &beta;<sub></sub> (it uses &alpha;<sub></sub> = &beta;<sub></sub> = 0.5). The ability to set priors based on what we know about our experimental setting is an important feature of Bayesian statistics <a href="http://developers.lyst.com/2014/05/10/bayesian-ab-testing/" target="_blank" rel="noopener">that can help reduce the number of false positives</a>. Hiding the priors in PeakConversion's calculator makes it easier to use but less powerful than Lyst's tool. In addition, Lyst's calculator presents the distribution of differences between the success rates of A and B, i.e., the _effect size_. This is important because we may not bother implementing certain changes if the effect is negligible, even if the probability of one variant being better than the other is very close to 1.

Despite being more powerful, I find Lyst's calculator just a bit too technical. Specifically, setting the &alpha;<sub></sub> and &beta;<sub></sub> priors requires some familiarity with the beta distribution, which many people don't have. Also, the effect size distribution is important, but can be hard to get one's head around. Therefore, I decided to extend Lyst's calculator, aiming to release a new tool that is both powerful and easy to use.

## Building the new calculator

The source code for Lyst's calculator is <a href="https://github.com/ssaw/BayesianTestJS" target="_blank" rel="noopener">available on GitHub</a>, so I decided to use that as the foundation of the new calculator. The first step was to convert the code from HTML, CSS, and JavaScript to Jade, Sass, and CoffeeScript, and clean up some code duplication. As the calculator is served from my <a href="https://yanirs.github.io/tools/split-test-calculator/" target="_blank" rel="noopener">GitHub Pages domain</a>, it was easiest to put <a href="https://github.com/yanirs/yanirs.github.io/tree/master/tools/split-test-calculator/src" target="_blank" rel="noopener">all the code</a> in that repository. Once I had an environment and codebase that I was happy with, it was time to make functional changes:

  * Change the layout to be responsive, so it'd work well on mobile devices.
  * Enable sharing of results by changing the URL when the input changes.
  * Provide clear instructions, so that the calculator can be used by people who don't necessarily have a strong background in statistics.
  * Allow users to set priors based on more familiar figures than the beta distribution's &alpha;<sub></sub> and &beta;<sub></sub> priors.
  * Make a clear and well-justified recommendation on how to proceed.

While the first two changes were straightforward to implement, the other points were somewhat more challenging. Specifically, providing clear explanations that assume little background knowledge isn't simple, and I still feel that the current version of the new calculator is a bit too wordy (this may be improved in the future based on user feedback &ndash; suggestions welcome). Life would be easier if everyone thought of observed values as being drawn from distributions, but in my experience this is not always the case. However, I believe it is important to communicate the reality of uncertainty, so I don't want to hide it from users of the calculator, even at the price of more elaborate explanations.

Making the priors more intuitive was a bit tricky. At first, I thought I'd let users state their prior knowledge in terms of the mean and variance of past performance, relying on the fact that for Beta(&alpha;,&nbsp;&beta;) the mean &mu; is &alpha;&nbsp;/&nbsp;(&alpha;&nbsp;+&nbsp;&beta;), and the variance &sigma;<sup>2</sup> is &alpha;&beta;&nbsp;/&nbsp;(&alpha;&nbsp;+&nbsp;&beta;)<sup>2</sup>(&alpha;&nbsp;+&nbsp;&beta;&nbsp;+&nbsp;1). The problem is that while the mean is simple to set, as it is always in the (0,&nbsp;1) range, the upper bound for the variance depends on the mean. Specifically, <a href="http://stats.stackexchange.com/a/12239" target="_blank" rel="noopener">it can be shown</a> that the variance is in the range (0,&nbsp;&mu;(1&nbsp;&#8211;&nbsp;&mu;)). Therefore, I decided to let users quantify their uncertainty about the mean as a number _u_ in the range (0,&nbsp;1), where &sigma;<sup>2</sup>&nbsp;=&nbsp;_u_&mu;(1&nbsp;&#8211;&nbsp;&mu;). Having played with the calculator a bit, I think this makes it easier to set good informative priors. It is also worth noting that I considered allowing users to set different priors for the control and test group, but decided against it to reduce complexity. In addition, it makes sense to have the same prior for both groups &ndash; if you have a strong belief or knowledge on which one is going to perform better, you probably don't need to run an experiment.

One of the main reasons I decided to build the calculator was because I wanted a tool that outputs a clear recommendation. This proved to be the most challenging (and interesting) part of this project, as there are quite a few options for Bayesian stopping rules. After reading <a href="http://varianceexplained.org/r/bayesian-ab-testing/" target="_blank" rel="noopener">David Robinson's review of the limitations of a stopping rule based on the expected loss</a>, and a few of the other resources mentioned in his post, I decided to go with a combination of <a href="http://doingbayesiandataanalysis.blogspot.com.au/2013/11/optional-stopping-in-data-collection-p.html" target="_blank" rel="noopener">the third and fourth rules tested by John Kruschke</a>. These rules rely on a threshold of caring, which is the minimum effect size that is seen as significant by the user. For example, if we're running experiments on the conversion rate of a landing page, we may decide that we don't care if the absolute change in conversion rate is less than 0.1%. Given this threshold and data from the experiment, the following recommendations are possible:

  1. _Stop the experiment and implement either variant_, because the difference between the variants is smaller than the threshold.
  2. _Stop the experiment and implement the winning variant_, because the difference between the variants is greater than the threshold.
  3. _Keep running the experiment_, because there isn't enough data to make a decision.

Formally, Kruschke's rules work as follows. Given the minimum effect threshold _t_, we define a region of practical equivalence (ROPE) to zero difference as the interval [-_t_,&nbsp;_t_]. Then, we compare the ROPE to the 95% high density interval (HDI) of the distribution of differences between A and B. When comparing the ROPE and HDI, there are three options that correspond to the recommendations above:

  1. The ROPE is completely contained in the HDI (stop the experiment and implement either variant).
  2. The intersection between the ROPE and HDI is empty (stop the experiment and implement the winning variant).
  3. The ROPE and HDI only partly overlap (keep running the experiment).

Kruschke's post shows that making the rule more restrictive by adding a notion of user-settable _precision_ can reduce the rate of false positives. The idea is to stop only if the HDI is narrower than precision multiplied by the width of the ROPE. Intuitively, this forces the experimenter to collect more data because it makes the posterior distributions narrower (as shown by the charts above). I found it hard to explain the idea of precision, and didn't want to confuse users by adding another parameter, so I decided to use a constant precision value of 0.8. If the ROPE and HDI don't overlap, the tool makes a recommendation to stop, accompanied by a binary level of confidence: _high_ if the precision condition is met, and _low_ otherwise.

Putting in the numbers from the running example (T<sub>A</sub> = 200, S<sub>A</sub> = 120, T<sub>B</sub> = 200, and S<sub>B</sub> = 100) together with a minimum effect of 1%, prior success rate of 50%, and 57.74% uncertainty (equivalent to &alpha;<sub></sub> = &beta;<sub></sub> = 1), we get the following output:

{{< figure src="calcualtor-recommendation-example.png" alt="Calculator recommendation example" link="https://yanirs.github.io/tools/split-test-calculator/#prior-mean=50,prior-uncertainty=57.74,minimum-effect=1,control-trials=200,control-successes=120,test-trials=200,test-successes=100" >}}

<a href="https://yanirs.github.io/tools/split-test-calculator/#prior-mean=50,prior-uncertainty=57.74,minimum-effect=1,control-trials=200,control-successes=120,test-trials=200,test-successes=100" target="_blank" rel="noopener">The full results</a> also include plots of the distributions and their high density intervals. I'm pretty happy with the richer information provided by the calculator, though it still has some limitations and areas that can be improved.

## Limitations and potential improvements

As mentioned above, I'd love to reduce the wordiness of the calculator while keeping it self-contained, but I need some feedback to understand if any explanations are redundant. It'd also be great to reduce the reliance on magic numbers, such as the 95% HDI and 0.8 precision used for generating a recommendation. However, making these settable by users would increase the complexity of using the calculator, which is already harder to use than the frequentist alternative. Nonetheless, it's important to remember that oversimplification is the reason why it's easier to make the wrong decision when following the classical approach.

Other potential changes include <a href="http://varianceexplained.org/r/bayesian_ab_baseball/" target="_blank" rel="noopener">switching to a closed-form formula rather than draws from a distribution</a>, comparing more than two variants, and improving Kruschke's stopping rules by simulating more scenarios than those considered in his post. In addition, I'd like to go beyond binary responses (success/failure) to support continuous rewards (e.g., revenue), and allow users to specify different costs for the variants (e.g., implementing B may cost more than sticking with A).

Finally, it is important to keep in mind that significance testing can't tell you whether your sample is representative of the population. For example, if you run an experiment on a very popular website, you can get a sample of thousands of people within a few minutes. Concluding an experiment based on such a sample is probably a bad idea, as it is plausible that you would reach different conclusions if you kept running the experiment for a few days, to reduce the effect that the time of day has on the results. Similarly, a few days may not be enough if your user population behaves differently on weekends &ndash; you would need to run the experiment over a few weeks. This can be extended to months and years to rule out seasonal effects, but it is up to the experimenter to weigh the practicality of considering such factors versus the need to make decisions (see articles by <a href="http://conversionxl.com/statistical-significance-does-not-equal-validity/" target="_blank" rel="noopener">Peep Laja</a>, <a href="http://www.qubit.com/sites/default/files/pdf/mostwinningabtestresultsareillusory_0.pdf" target="_blank" rel="noopener">Martin Goodson</a>, <a href="https://blog.crazyegg.com/2016/03/22/anti-cookbook-ab-testing/" target="_blank" rel="noopener">Sam Ju</a>, and <a href="http://www.exp-platform.com/Documents/2014%20experimentersRulesOfThumb.pdf" target="_blank" rel="noopener">Kohavi et al.</a> for more details). The main thing to remember is that **you just cannot completely eliminate uncertainty and the need to consider background knowledge**, which is why I believe that helping more people follow the Bayesian approach is a step in the right direction.

 [1]: https://yanirseroussi.com/2016/02/14/why-you-should-stop-worrying-about-deep-learning-and-deepen-your-understanding-of-causality-instead/
